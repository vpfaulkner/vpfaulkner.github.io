<p>It is so easy to resort to class methods in Ruby. The behavior you are trying to implement seems to be stateless and writing a class method just seems easier.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">FileCompressor</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">compress</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
    <span class="c1"># compressing...</span>
  <span class="k">end</span>

<span class="k">end</span></code></pre></figure>

<p>You think to yourself here: the idea of state does not seem that attractive here. This compression should be completely stateless as the only needed in our case is what we are passing in as its argument, the file.</p>

<p>However, let’s say your compression logic begins to grow a little bit:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">FileCompressor</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">compress</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
    <span class="n">determine_file_type</span>
    <span class="c1"># compressing...</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">determine_file_type</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
    <span class="c1"># determining...</span>
  <span class="k">end</span>

<span class="k">end</span></code></pre></figure>

<p>OK, no big deal right? Well, suddenly the complexity of your compression logic is growing and each individual method must use only its argument(s) as context. You are navigating a slippery slope here that will make your code not only harder to read and write but also more resistant to refactoring. The key idea is that that with each addition of behavior you add via a new method your class is becoming more and more state-like yet it has no way to store state because you never instantiated it. Your code is becoming more and more procedural and resisting that natural advantages offered by an object-oriented design. At this point I would recommend rethinking your class:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">FileCompressor</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
    <span class="vi">@file</span> <span class="o">=</span> <span class="n">file</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">compress</span>
    <span class="n">determine_file_type</span>
    <span class="c1"># compressing...</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">determine_file_type</span>
    <span class="c1"># determining...</span>
  <span class="k">end</span>

<span class="k">end</span></code></pre></figure>

<p>This design rethink will give you a more natural way to accommodate change in behavior and prevent class method “feature envy” here.</p>
